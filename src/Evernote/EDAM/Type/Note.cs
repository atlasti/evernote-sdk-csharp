/**
 * <auto-generated>
 * Autogenerated by Thrift Compiler (0.16.0)
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 * </auto-generated>
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Thrift;
using Thrift.Collections;

using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;
using Thrift.Transport;
using Thrift.Transport.Client;
using Thrift.Transport.Server;
using Thrift.Processor;


#nullable disable                // suppress C# 8.0 nullable contexts (we still support earlier versions)
#pragma warning disable IDE0079  // remove unnecessary pragmas
#pragma warning disable IDE1006  // parts of the code use IDL spelling
#pragma warning disable IDE0083  // pattern matching "that is not SomeType" requires net5.0 but we still support earlier versions

namespace Evernote.EDAM.Type
{

  /// <summary>
  /// Represents a single note in the user's account.
  /// 
  /// <dl>
  /// <dt>guid</dt>
  ///   <dd>The unique identifier of this note.  Will be set by the
  ///   server, but will be omitted by clients calling NoteStore.createNote()
  ///   <br/>
  ///   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
  ///   <br/>
  ///   Regex:  EDAM_GUID_REGEX
  ///   </dd>
  /// 
  /// <dt>title</dt>
  ///   <dd>The subject of the note.  Can't begin or end with a space.
  ///   <br/>
  ///   Length:  EDAM_NOTE_TITLE_LEN_MIN - EDAM_NOTE_TITLE_LEN_MAX
  ///   <br/>
  ///   Regex:  EDAM_NOTE_TITLE_REGEX
  ///   </dd>
  /// 
  /// <dt>content</dt>
  ///   <dd>The XHTML block that makes up the note.  This is
  ///   the canonical form of the note's contents, so will include abstract
  ///   Evernote tags for internal resource references.  A client may create
  ///   a separate transformed version of this content for internal presentation,
  ///   but the same canonical bytes should be used for transmission and
  ///   comparison unless the user chooses to modify their content.
  ///   <br/>
  ///   Length:  EDAM_NOTE_CONTENT_LEN_MIN - EDAM_NOTE_CONTENT_LEN_MAX
  ///   </dd>
  /// 
  /// <dt>contentHash</dt>
  ///   <dd>The binary MD5 checksum of the UTF-8 encoded content
  ///   body. This will always be set by the server, but clients may choose to omit
  ///   this when they submit a note with content.
  ///   <br/>
  ///   Length:  EDAM_HASH_LEN (exactly)
  ///   </dd>
  /// 
  /// <dt>contentLength</dt>
  ///   <dd>The number of Unicode characters in the content of
  ///   the note.  This will always be set by the service, but clients may choose
  ///   to omit this value when they submit a Note.
  ///   </dd>
  /// 
  /// <dt>created</dt>
  ///   <dd>The date and time when the note was created in one of the
  ///   clients.  In most cases, this will match the user's sense of when
  ///   the note was created, and ordering between notes will be based on
  ///   ordering of this field.  However, this is not a "reliable" timestamp
  ///   if a client has an incorrect clock, so it cannot provide a true absolute
  ///   ordering between notes.  Notes created directly through the service
  ///   (e.g. via the web GUI) will have an absolutely ordered "created" value.
  ///   </dd>
  /// 
  /// <dt>updated</dt>
  ///   <dd>The date and time when the note was last modified in one of
  ///   the clients.  In most cases, this will match the user's sense of when
  ///   the note was modified, but this field may not be absolutely reliable
  ///   due to the possibility of client clock errors.
  ///   </dd>
  /// 
  /// <dt>deleted</dt>
  ///   <dd>If present, the note is considered "deleted", and this
  ///   stores the date and time when the note was deleted by one of the clients.
  ///   In most cases, this will match the user's sense of when the note was
  ///   deleted, but this field may be unreliable due to the possibility of
  ///   client clock errors.
  ///   </dd>
  /// 
  /// <dt>active</dt>
  ///   <dd>If the note is available for normal actions and viewing,
  ///   this flag will be set to true.
  ///   </dd>
  /// 
  /// <dt>updateSequenceNum</dt>
  ///   <dd>A number identifying the last transaction to
  ///   modify the state of this note (including changes to the note's attributes
  ///   or resources).  The USN values are sequential within an account,
  ///   and can be used to compare the order of modifications within the service.
  ///   </dd>
  /// 
  /// <dt>notebookGuid</dt>
  ///   <dd>The unique identifier of the notebook that contains
  ///   this note.  If no notebookGuid is provided on a call to createNote(), the
  ///   default notebook will be used instead.
  ///   <br/>
  ///   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
  ///   <br/>
  ///   Regex:  EDAM_GUID_REGEX
  ///   </dd>
  /// 
  /// <dt>tagGuids</dt>
  ///   <dd>A list of the GUID identifiers for tags that are applied to this note.
  ///   This may be provided in a call to createNote() to unambiguously declare
  ///   the tags that should be assigned to the new note.  Alternately, clients
  ///   may pass the names of desired tags via the 'tagNames' field during
  ///   note creation.
  ///   If the list of tags are omitted on a call to createNote(), then
  ///   the server will assume that no changes have been made to the resources.
  ///   Maximum:  EDAM_NOTE_TAGS_MAX tags per note
  ///   </dd>
  /// 
  /// <dt>resources</dt>
  ///   <dd>The list of resources that are embedded within this note.
  ///   If the list of resources are omitted on a call to updateNote(), then
  ///   the server will assume that no changes have been made to the resources.
  ///   The binary contents of the resources must be provided when the resource
  ///   is first sent to the service, but it will be omitted by the service when
  ///   the Note is returned in the future.
  ///   Maximum:  EDAM_NOTE_RESOURCES_MAX resources per note
  ///   </dd>
  /// 
  /// <dt>attributes</dt>
  ///   <dd>A list of the attributes for this note.
  ///   If the list of attributes are omitted on a call to updateNote(), then
  ///   the server will assume that no changes have been made to the resources.
  ///   </dd>
  /// 
  /// <dt>tagNames</dt>
  ///   <dd>May be provided by clients during calls to createNote() as an
  ///   alternative to providing the tagGuids of existing tags.  If any tagNames
  ///   are provided during createNote(), these will be found, or created if they
  ///   don't already exist.  Created tags will have no parent (they will be at
  ///   the top level of the tag panel).
  ///   </dd>
  /// 
  /// <dt>sharedNotes</dt>
  ///   <dd>The list of recipients with whom this note has been shared. This field will be unset if
  ///     the caller has access to the note via the containing notebook, but does not have activity
  ///     feed permission for that notebook. This field is read-only. Clients may not make changes to
  ///     a note's sharing state via this field.
  ///   </dd>
  /// 
  ///   <dt>restrictions</dt>
  ///   <dd>If this field is set, the user has note-level permissions that may differ from their
  ///     notebook-level permissions. In this case, the restrictions structure specifies
  ///     a set of restrictions limiting the actions that a user may take on the note based
  ///     on their note-level permissions. If this field is unset, then there are no
  ///     note-specific restrictions. However, a client may still be limited based on the user's
  ///     notebook permissions.</dd>
  /// </dl>
  /// </summary>
  public partial class Note : TBase
  {
    private string _guid;
    private string _title;
    private string _content;
    private byte[] _contentHash;
    private int _contentLength;
    private long _created;
    private long _updated;
    private long _deleted;
    private bool _active;
    private int _updateSequenceNum;
    private string _notebookGuid;
    private List<string> _tagGuids;
    private List<global::Evernote.EDAM.Type.Resource> _resources;
    private global::Evernote.EDAM.Type.NoteAttributes _attributes;
    private List<string> _tagNames;
    private List<global::Evernote.EDAM.Type.SharedNote> _sharedNotes;
    private global::Evernote.EDAM.Type.NoteRestrictions _restrictions;
    private global::Evernote.EDAM.Type.NoteLimits _limits;

    public string Guid
    {
      get
      {
        return _guid;
      }
      set
      {
        __isset.guid = true;
        this._guid = value;
      }
    }

    public string Title
    {
      get
      {
        return _title;
      }
      set
      {
        __isset.title = true;
        this._title = value;
      }
    }

    public string Content
    {
      get
      {
        return _content;
      }
      set
      {
        __isset.content = true;
        this._content = value;
      }
    }

    public byte[] ContentHash
    {
      get
      {
        return _contentHash;
      }
      set
      {
        __isset.contentHash = true;
        this._contentHash = value;
      }
    }

    public int ContentLength
    {
      get
      {
        return _contentLength;
      }
      set
      {
        __isset.contentLength = true;
        this._contentLength = value;
      }
    }

    public long Created
    {
      get
      {
        return _created;
      }
      set
      {
        __isset.created = true;
        this._created = value;
      }
    }

    public long Updated
    {
      get
      {
        return _updated;
      }
      set
      {
        __isset.updated = true;
        this._updated = value;
      }
    }

    public long Deleted
    {
      get
      {
        return _deleted;
      }
      set
      {
        __isset.deleted = true;
        this._deleted = value;
      }
    }

    public bool Active
    {
      get
      {
        return _active;
      }
      set
      {
        __isset.active = true;
        this._active = value;
      }
    }

    public int UpdateSequenceNum
    {
      get
      {
        return _updateSequenceNum;
      }
      set
      {
        __isset.updateSequenceNum = true;
        this._updateSequenceNum = value;
      }
    }

    public string NotebookGuid
    {
      get
      {
        return _notebookGuid;
      }
      set
      {
        __isset.notebookGuid = true;
        this._notebookGuid = value;
      }
    }

    public List<string> TagGuids
    {
      get
      {
        return _tagGuids;
      }
      set
      {
        __isset.tagGuids = true;
        this._tagGuids = value;
      }
    }

    public List<global::Evernote.EDAM.Type.Resource> Resources
    {
      get
      {
        return _resources;
      }
      set
      {
        __isset.resources = true;
        this._resources = value;
      }
    }

    public global::Evernote.EDAM.Type.NoteAttributes Attributes
    {
      get
      {
        return _attributes;
      }
      set
      {
        __isset.attributes = true;
        this._attributes = value;
      }
    }

    public List<string> TagNames
    {
      get
      {
        return _tagNames;
      }
      set
      {
        __isset.tagNames = true;
        this._tagNames = value;
      }
    }

    public List<global::Evernote.EDAM.Type.SharedNote> SharedNotes
    {
      get
      {
        return _sharedNotes;
      }
      set
      {
        __isset.sharedNotes = true;
        this._sharedNotes = value;
      }
    }

    public global::Evernote.EDAM.Type.NoteRestrictions Restrictions
    {
      get
      {
        return _restrictions;
      }
      set
      {
        __isset.restrictions = true;
        this._restrictions = value;
      }
    }

    public global::Evernote.EDAM.Type.NoteLimits Limits
    {
      get
      {
        return _limits;
      }
      set
      {
        __isset.limits = true;
        this._limits = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool guid;
      public bool title;
      public bool content;
      public bool contentHash;
      public bool contentLength;
      public bool created;
      public bool updated;
      public bool deleted;
      public bool active;
      public bool updateSequenceNum;
      public bool notebookGuid;
      public bool tagGuids;
      public bool resources;
      public bool attributes;
      public bool tagNames;
      public bool sharedNotes;
      public bool restrictions;
      public bool limits;
    }

    public Note()
    {
    }

    public Note DeepCopy()
    {
      var tmp107 = new Note();
      if((Guid != null) && __isset.guid)
      {
        tmp107.Guid = this.Guid;
      }
      tmp107.__isset.guid = this.__isset.guid;
      if((Title != null) && __isset.title)
      {
        tmp107.Title = this.Title;
      }
      tmp107.__isset.title = this.__isset.title;
      if((Content != null) && __isset.content)
      {
        tmp107.Content = this.Content;
      }
      tmp107.__isset.content = this.__isset.content;
      if((ContentHash != null) && __isset.contentHash)
      {
        tmp107.ContentHash = this.ContentHash.ToArray();
      }
      tmp107.__isset.contentHash = this.__isset.contentHash;
      if(__isset.contentLength)
      {
        tmp107.ContentLength = this.ContentLength;
      }
      tmp107.__isset.contentLength = this.__isset.contentLength;
      if(__isset.created)
      {
        tmp107.Created = this.Created;
      }
      tmp107.__isset.created = this.__isset.created;
      if(__isset.updated)
      {
        tmp107.Updated = this.Updated;
      }
      tmp107.__isset.updated = this.__isset.updated;
      if(__isset.deleted)
      {
        tmp107.Deleted = this.Deleted;
      }
      tmp107.__isset.deleted = this.__isset.deleted;
      if(__isset.active)
      {
        tmp107.Active = this.Active;
      }
      tmp107.__isset.active = this.__isset.active;
      if(__isset.updateSequenceNum)
      {
        tmp107.UpdateSequenceNum = this.UpdateSequenceNum;
      }
      tmp107.__isset.updateSequenceNum = this.__isset.updateSequenceNum;
      if((NotebookGuid != null) && __isset.notebookGuid)
      {
        tmp107.NotebookGuid = this.NotebookGuid;
      }
      tmp107.__isset.notebookGuid = this.__isset.notebookGuid;
      if((TagGuids != null) && __isset.tagGuids)
      {
        tmp107.TagGuids = this.TagGuids.DeepCopy();
      }
      tmp107.__isset.tagGuids = this.__isset.tagGuids;
      if((Resources != null) && __isset.resources)
      {
        tmp107.Resources = this.Resources.DeepCopy();
      }
      tmp107.__isset.resources = this.__isset.resources;
      if((Attributes != null) && __isset.attributes)
      {
        tmp107.Attributes = (global::Evernote.EDAM.Type.NoteAttributes)this.Attributes.DeepCopy();
      }
      tmp107.__isset.attributes = this.__isset.attributes;
      if((TagNames != null) && __isset.tagNames)
      {
        tmp107.TagNames = this.TagNames.DeepCopy();
      }
      tmp107.__isset.tagNames = this.__isset.tagNames;
      if((SharedNotes != null) && __isset.sharedNotes)
      {
        tmp107.SharedNotes = this.SharedNotes.DeepCopy();
      }
      tmp107.__isset.sharedNotes = this.__isset.sharedNotes;
      if((Restrictions != null) && __isset.restrictions)
      {
        tmp107.Restrictions = (global::Evernote.EDAM.Type.NoteRestrictions)this.Restrictions.DeepCopy();
      }
      tmp107.__isset.restrictions = this.__isset.restrictions;
      if((Limits != null) && __isset.limits)
      {
        tmp107.Limits = (global::Evernote.EDAM.Type.NoteLimits)this.Limits.DeepCopy();
      }
      tmp107.__isset.limits = this.__isset.limits;
      return tmp107;
    }

    public async global::System.Threading.Tasks.Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Guid = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.String)
              {
                Title = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.String)
              {
                Content = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 4:
              if (field.Type == TType.String)
              {
                ContentHash = await iprot.ReadBinaryAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 5:
              if (field.Type == TType.I32)
              {
                ContentLength = await iprot.ReadI32Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 6:
              if (field.Type == TType.I64)
              {
                Created = await iprot.ReadI64Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 7:
              if (field.Type == TType.I64)
              {
                Updated = await iprot.ReadI64Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 8:
              if (field.Type == TType.I64)
              {
                Deleted = await iprot.ReadI64Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 9:
              if (field.Type == TType.Bool)
              {
                Active = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 10:
              if (field.Type == TType.I32)
              {
                UpdateSequenceNum = await iprot.ReadI32Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 11:
              if (field.Type == TType.String)
              {
                NotebookGuid = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 12:
              if (field.Type == TType.List)
              {
                {
                  TList _list108 = await iprot.ReadListBeginAsync(cancellationToken);
                  TagGuids = new List<string>(_list108.Count);
                  for(int _i109 = 0; _i109 < _list108.Count; ++_i109)
                  {
                    string _elem110;
                    _elem110 = await iprot.ReadStringAsync(cancellationToken);
                    TagGuids.Add(_elem110);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 13:
              if (field.Type == TType.List)
              {
                {
                  TList _list111 = await iprot.ReadListBeginAsync(cancellationToken);
                  Resources = new List<global::Evernote.EDAM.Type.Resource>(_list111.Count);
                  for(int _i112 = 0; _i112 < _list111.Count; ++_i112)
                  {
                    global::Evernote.EDAM.Type.Resource _elem113;
                    _elem113 = new global::Evernote.EDAM.Type.Resource();
                    await _elem113.ReadAsync(iprot, cancellationToken);
                    Resources.Add(_elem113);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 14:
              if (field.Type == TType.Struct)
              {
                Attributes = new global::Evernote.EDAM.Type.NoteAttributes();
                await Attributes.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 15:
              if (field.Type == TType.List)
              {
                {
                  TList _list114 = await iprot.ReadListBeginAsync(cancellationToken);
                  TagNames = new List<string>(_list114.Count);
                  for(int _i115 = 0; _i115 < _list114.Count; ++_i115)
                  {
                    string _elem116;
                    _elem116 = await iprot.ReadStringAsync(cancellationToken);
                    TagNames.Add(_elem116);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 16:
              if (field.Type == TType.List)
              {
                {
                  TList _list117 = await iprot.ReadListBeginAsync(cancellationToken);
                  SharedNotes = new List<global::Evernote.EDAM.Type.SharedNote>(_list117.Count);
                  for(int _i118 = 0; _i118 < _list117.Count; ++_i118)
                  {
                    global::Evernote.EDAM.Type.SharedNote _elem119;
                    _elem119 = new global::Evernote.EDAM.Type.SharedNote();
                    await _elem119.ReadAsync(iprot, cancellationToken);
                    SharedNotes.Add(_elem119);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 17:
              if (field.Type == TType.Struct)
              {
                Restrictions = new global::Evernote.EDAM.Type.NoteRestrictions();
                await Restrictions.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 18:
              if (field.Type == TType.Struct)
              {
                Limits = new global::Evernote.EDAM.Type.NoteLimits();
                await Limits.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async global::System.Threading.Tasks.Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var tmp120 = new TStruct("Note");
        await oprot.WriteStructBeginAsync(tmp120, cancellationToken);
        var tmp121 = new TField();
        if((Guid != null) && __isset.guid)
        {
          tmp121.Name = "guid";
          tmp121.Type = TType.String;
          tmp121.ID = 1;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteStringAsync(Guid, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Title != null) && __isset.title)
        {
          tmp121.Name = "title";
          tmp121.Type = TType.String;
          tmp121.ID = 2;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteStringAsync(Title, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Content != null) && __isset.content)
        {
          tmp121.Name = "content";
          tmp121.Type = TType.String;
          tmp121.ID = 3;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteStringAsync(Content, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((ContentHash != null) && __isset.contentHash)
        {
          tmp121.Name = "contentHash";
          tmp121.Type = TType.String;
          tmp121.ID = 4;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteBinaryAsync(ContentHash, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.contentLength)
        {
          tmp121.Name = "contentLength";
          tmp121.Type = TType.I32;
          tmp121.ID = 5;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteI32Async(ContentLength, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.created)
        {
          tmp121.Name = "created";
          tmp121.Type = TType.I64;
          tmp121.ID = 6;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteI64Async(Created, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.updated)
        {
          tmp121.Name = "updated";
          tmp121.Type = TType.I64;
          tmp121.ID = 7;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteI64Async(Updated, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.deleted)
        {
          tmp121.Name = "deleted";
          tmp121.Type = TType.I64;
          tmp121.ID = 8;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteI64Async(Deleted, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.active)
        {
          tmp121.Name = "active";
          tmp121.Type = TType.Bool;
          tmp121.ID = 9;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteBoolAsync(Active, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.updateSequenceNum)
        {
          tmp121.Name = "updateSequenceNum";
          tmp121.Type = TType.I32;
          tmp121.ID = 10;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteI32Async(UpdateSequenceNum, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((NotebookGuid != null) && __isset.notebookGuid)
        {
          tmp121.Name = "notebookGuid";
          tmp121.Type = TType.String;
          tmp121.ID = 11;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await oprot.WriteStringAsync(NotebookGuid, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((TagGuids != null) && __isset.tagGuids)
        {
          tmp121.Name = "tagGuids";
          tmp121.Type = TType.List;
          tmp121.ID = 12;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.String, TagGuids.Count), cancellationToken);
            foreach (string _iter122 in TagGuids)
            {
              await oprot.WriteStringAsync(_iter122, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Resources != null) && __isset.resources)
        {
          tmp121.Name = "resources";
          tmp121.Type = TType.List;
          tmp121.ID = 13;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, Resources.Count), cancellationToken);
            foreach (global::Evernote.EDAM.Type.Resource _iter123 in Resources)
            {
              await _iter123.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Attributes != null) && __isset.attributes)
        {
          tmp121.Name = "attributes";
          tmp121.Type = TType.Struct;
          tmp121.ID = 14;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await Attributes.WriteAsync(oprot, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((TagNames != null) && __isset.tagNames)
        {
          tmp121.Name = "tagNames";
          tmp121.Type = TType.List;
          tmp121.ID = 15;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.String, TagNames.Count), cancellationToken);
            foreach (string _iter124 in TagNames)
            {
              await oprot.WriteStringAsync(_iter124, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((SharedNotes != null) && __isset.sharedNotes)
        {
          tmp121.Name = "sharedNotes";
          tmp121.Type = TType.List;
          tmp121.ID = 16;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, SharedNotes.Count), cancellationToken);
            foreach (global::Evernote.EDAM.Type.SharedNote _iter125 in SharedNotes)
            {
              await _iter125.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Restrictions != null) && __isset.restrictions)
        {
          tmp121.Name = "restrictions";
          tmp121.Type = TType.Struct;
          tmp121.ID = 17;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await Restrictions.WriteAsync(oprot, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Limits != null) && __isset.limits)
        {
          tmp121.Name = "limits";
          tmp121.Type = TType.Struct;
          tmp121.ID = 18;
          await oprot.WriteFieldBeginAsync(tmp121, cancellationToken);
          await Limits.WriteAsync(oprot, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      if (!(that is Note other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.guid == other.__isset.guid) && ((!__isset.guid) || (global::System.Object.Equals(Guid, other.Guid))))
        && ((__isset.title == other.__isset.title) && ((!__isset.title) || (global::System.Object.Equals(Title, other.Title))))
        && ((__isset.content == other.__isset.content) && ((!__isset.content) || (global::System.Object.Equals(Content, other.Content))))
        && ((__isset.contentHash == other.__isset.contentHash) && ((!__isset.contentHash) || (TCollections.Equals(ContentHash, other.ContentHash))))
        && ((__isset.contentLength == other.__isset.contentLength) && ((!__isset.contentLength) || (global::System.Object.Equals(ContentLength, other.ContentLength))))
        && ((__isset.created == other.__isset.created) && ((!__isset.created) || (global::System.Object.Equals(Created, other.Created))))
        && ((__isset.updated == other.__isset.updated) && ((!__isset.updated) || (global::System.Object.Equals(Updated, other.Updated))))
        && ((__isset.deleted == other.__isset.deleted) && ((!__isset.deleted) || (global::System.Object.Equals(Deleted, other.Deleted))))
        && ((__isset.active == other.__isset.active) && ((!__isset.active) || (global::System.Object.Equals(Active, other.Active))))
        && ((__isset.updateSequenceNum == other.__isset.updateSequenceNum) && ((!__isset.updateSequenceNum) || (global::System.Object.Equals(UpdateSequenceNum, other.UpdateSequenceNum))))
        && ((__isset.notebookGuid == other.__isset.notebookGuid) && ((!__isset.notebookGuid) || (global::System.Object.Equals(NotebookGuid, other.NotebookGuid))))
        && ((__isset.tagGuids == other.__isset.tagGuids) && ((!__isset.tagGuids) || (TCollections.Equals(TagGuids, other.TagGuids))))
        && ((__isset.resources == other.__isset.resources) && ((!__isset.resources) || (TCollections.Equals(Resources, other.Resources))))
        && ((__isset.attributes == other.__isset.attributes) && ((!__isset.attributes) || (global::System.Object.Equals(Attributes, other.Attributes))))
        && ((__isset.tagNames == other.__isset.tagNames) && ((!__isset.tagNames) || (TCollections.Equals(TagNames, other.TagNames))))
        && ((__isset.sharedNotes == other.__isset.sharedNotes) && ((!__isset.sharedNotes) || (TCollections.Equals(SharedNotes, other.SharedNotes))))
        && ((__isset.restrictions == other.__isset.restrictions) && ((!__isset.restrictions) || (global::System.Object.Equals(Restrictions, other.Restrictions))))
        && ((__isset.limits == other.__isset.limits) && ((!__isset.limits) || (global::System.Object.Equals(Limits, other.Limits))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if((Guid != null) && __isset.guid)
        {
          hashcode = (hashcode * 397) + Guid.GetHashCode();
        }
        if((Title != null) && __isset.title)
        {
          hashcode = (hashcode * 397) + Title.GetHashCode();
        }
        if((Content != null) && __isset.content)
        {
          hashcode = (hashcode * 397) + Content.GetHashCode();
        }
        if((ContentHash != null) && __isset.contentHash)
        {
          hashcode = (hashcode * 397) + ContentHash.GetHashCode();
        }
        if(__isset.contentLength)
        {
          hashcode = (hashcode * 397) + ContentLength.GetHashCode();
        }
        if(__isset.created)
        {
          hashcode = (hashcode * 397) + Created.GetHashCode();
        }
        if(__isset.updated)
        {
          hashcode = (hashcode * 397) + Updated.GetHashCode();
        }
        if(__isset.deleted)
        {
          hashcode = (hashcode * 397) + Deleted.GetHashCode();
        }
        if(__isset.active)
        {
          hashcode = (hashcode * 397) + Active.GetHashCode();
        }
        if(__isset.updateSequenceNum)
        {
          hashcode = (hashcode * 397) + UpdateSequenceNum.GetHashCode();
        }
        if((NotebookGuid != null) && __isset.notebookGuid)
        {
          hashcode = (hashcode * 397) + NotebookGuid.GetHashCode();
        }
        if((TagGuids != null) && __isset.tagGuids)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(TagGuids);
        }
        if((Resources != null) && __isset.resources)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Resources);
        }
        if((Attributes != null) && __isset.attributes)
        {
          hashcode = (hashcode * 397) + Attributes.GetHashCode();
        }
        if((TagNames != null) && __isset.tagNames)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(TagNames);
        }
        if((SharedNotes != null) && __isset.sharedNotes)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(SharedNotes);
        }
        if((Restrictions != null) && __isset.restrictions)
        {
          hashcode = (hashcode * 397) + Restrictions.GetHashCode();
        }
        if((Limits != null) && __isset.limits)
        {
          hashcode = (hashcode * 397) + Limits.GetHashCode();
        }
      }
      return hashcode;
    }

    public override string ToString()
    {
      var tmp126 = new StringBuilder("Note(");
      int tmp127 = 0;
      if((Guid != null) && __isset.guid)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Guid: ");
        Guid.ToString(tmp126);
      }
      if((Title != null) && __isset.title)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Title: ");
        Title.ToString(tmp126);
      }
      if((Content != null) && __isset.content)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Content: ");
        Content.ToString(tmp126);
      }
      if((ContentHash != null) && __isset.contentHash)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("ContentHash: ");
        ContentHash.ToString(tmp126);
      }
      if(__isset.contentLength)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("ContentLength: ");
        ContentLength.ToString(tmp126);
      }
      if(__isset.created)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Created: ");
        Created.ToString(tmp126);
      }
      if(__isset.updated)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Updated: ");
        Updated.ToString(tmp126);
      }
      if(__isset.deleted)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Deleted: ");
        Deleted.ToString(tmp126);
      }
      if(__isset.active)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Active: ");
        Active.ToString(tmp126);
      }
      if(__isset.updateSequenceNum)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("UpdateSequenceNum: ");
        UpdateSequenceNum.ToString(tmp126);
      }
      if((NotebookGuid != null) && __isset.notebookGuid)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("NotebookGuid: ");
        NotebookGuid.ToString(tmp126);
      }
      if((TagGuids != null) && __isset.tagGuids)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("TagGuids: ");
        TagGuids.ToString(tmp126);
      }
      if((Resources != null) && __isset.resources)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Resources: ");
        Resources.ToString(tmp126);
      }
      if((Attributes != null) && __isset.attributes)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Attributes: ");
        Attributes.ToString(tmp126);
      }
      if((TagNames != null) && __isset.tagNames)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("TagNames: ");
        TagNames.ToString(tmp126);
      }
      if((SharedNotes != null) && __isset.sharedNotes)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("SharedNotes: ");
        SharedNotes.ToString(tmp126);
      }
      if((Restrictions != null) && __isset.restrictions)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Restrictions: ");
        Restrictions.ToString(tmp126);
      }
      if((Limits != null) && __isset.limits)
      {
        if(0 < tmp127++) { tmp126.Append(", "); }
        tmp126.Append("Limits: ");
        Limits.ToString(tmp126);
      }
      tmp126.Append(')');
      return tmp126.ToString();
    }
  }

}
