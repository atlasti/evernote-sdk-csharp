/**
 * <auto-generated>
 * Autogenerated by Thrift Compiler (0.16.0)
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 * </auto-generated>
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Thrift;
using Thrift.Collections;

using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;
using Thrift.Transport;
using Thrift.Transport.Client;
using Thrift.Transport.Server;
using Thrift.Processor;


#nullable disable                // suppress C# 8.0 nullable contexts (we still support earlier versions)
#pragma warning disable IDE0079  // remove unnecessary pragmas
#pragma warning disable IDE1006  // parts of the code use IDL spelling
#pragma warning disable IDE0083  // pattern matching "that is not SomeType" requires net5.0 but we still support earlier versions

namespace Evernote.EDAM.NoteStore
{

  /// <summary>
  ///  This structure is returned from calls to the findNotesMetadata function to
  ///  give the high-level metadata about a subset of Notes that are found to
  ///  match a specified NoteFilter in a search.
  /// 
  /// <dl>
  ///  <dt>startIndex</dt>
  ///    <dd>
  ///    The starting index within the overall set of notes.  This
  ///    is also the number of notes that are "before" this list in the set.
  ///    </dd>
  /// 
  ///  <dt>totalNotes</dt>
  ///    <dd>
  ///    The number of notes in the larger set.  This can be used
  ///    to calculate how many notes are "after" this note in the set.
  ///    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
  ///    </dd>
  /// 
  ///  <dt>notes</dt>
  ///    <dd>
  ///    The list of metadata for Notes in this range.  The set of optional fields
  ///    that are set in each metadata structure will depend on the
  ///    NotesMetadataResultSpec provided by the caller when the search was
  ///    performed.  Only the 'guid' field will be guaranteed to be set in each
  ///    Note.
  ///    </dd>
  /// 
  ///  <dt>stoppedWords</dt>
  ///    <dd>
  ///    If the NoteList was produced using a text based search
  ///    query that included words that are not indexed or searched by the service,
  ///    this will include a list of those ignored words.
  ///    </dd>
  /// 
  ///  <dt>searchedWords</dt>
  ///    <dd>
  ///    If the NoteList was produced using a text based search
  ///    query that included viable search words or quoted expressions, this will
  ///    include a list of those words.  Any stopped words will not be included
  ///    in this list.
  ///    </dd>
  /// 
  ///  <dt>updateCount</dt>
  ///    <dd>
  ///    Indicates the total number of transactions that have
  ///    been committed within the account.  This reflects (for example) the
  ///    number of discrete additions or modifications that have been made to
  ///    the data in this account (tags, notes, resources, etc.).
  ///    This number is the "high water mark" for Update Sequence Numbers (USN)
  ///    within the account.
  ///    </dd>
  /// 
  ///  <dt>searchContextBytes</dt>
  ///    <dd>
  ///    Specifies the correlating information about the current search session, in byte array.
  ///    </dd>
  /// 
  ///  <dt>debugInfo</dt>
  ///    <dd>
  ///    Depends on the value of <code>context</code> in NoteFilter, this field
  ///    may contain debug information if the service decides to do so.
  ///    </dd>
  /// 
  ///  </dl>
  /// </summary>
  public partial class NotesMetadataList : TBase
  {
    private List<string> _stoppedWords;
    private List<string> _searchedWords;
    private int _updateCount;
    private byte[] _searchContextBytes;
    private string _debugInfo;

    public int StartIndex { get; set; }

    public int TotalNotes { get; set; }

    public List<global::Evernote.EDAM.NoteStore.NoteMetadata> Notes { get; set; }

    public List<string> StoppedWords
    {
      get
      {
        return _stoppedWords;
      }
      set
      {
        __isset.stoppedWords = true;
        this._stoppedWords = value;
      }
    }

    public List<string> SearchedWords
    {
      get
      {
        return _searchedWords;
      }
      set
      {
        __isset.searchedWords = true;
        this._searchedWords = value;
      }
    }

    public int UpdateCount
    {
      get
      {
        return _updateCount;
      }
      set
      {
        __isset.updateCount = true;
        this._updateCount = value;
      }
    }

    public byte[] SearchContextBytes
    {
      get
      {
        return _searchContextBytes;
      }
      set
      {
        __isset.searchContextBytes = true;
        this._searchContextBytes = value;
      }
    }

    public string DebugInfo
    {
      get
      {
        return _debugInfo;
      }
      set
      {
        __isset.debugInfo = true;
        this._debugInfo = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool stoppedWords;
      public bool searchedWords;
      public bool updateCount;
      public bool searchContextBytes;
      public bool debugInfo;
    }

    public NotesMetadataList()
    {
    }

    public NotesMetadataList(int startIndex, int totalNotes, List<global::Evernote.EDAM.NoteStore.NoteMetadata> notes) : this()
    {
      this.StartIndex = startIndex;
      this.TotalNotes = totalNotes;
      this.Notes = notes;
    }

    public NotesMetadataList DeepCopy()
    {
      var tmp98 = new NotesMetadataList();
      tmp98.StartIndex = this.StartIndex;
      tmp98.TotalNotes = this.TotalNotes;
      if((Notes != null))
      {
        tmp98.Notes = this.Notes.DeepCopy();
      }
      if((StoppedWords != null) && __isset.stoppedWords)
      {
        tmp98.StoppedWords = this.StoppedWords.DeepCopy();
      }
      tmp98.__isset.stoppedWords = this.__isset.stoppedWords;
      if((SearchedWords != null) && __isset.searchedWords)
      {
        tmp98.SearchedWords = this.SearchedWords.DeepCopy();
      }
      tmp98.__isset.searchedWords = this.__isset.searchedWords;
      if(__isset.updateCount)
      {
        tmp98.UpdateCount = this.UpdateCount;
      }
      tmp98.__isset.updateCount = this.__isset.updateCount;
      if((SearchContextBytes != null) && __isset.searchContextBytes)
      {
        tmp98.SearchContextBytes = this.SearchContextBytes.ToArray();
      }
      tmp98.__isset.searchContextBytes = this.__isset.searchContextBytes;
      if((DebugInfo != null) && __isset.debugInfo)
      {
        tmp98.DebugInfo = this.DebugInfo;
      }
      tmp98.__isset.debugInfo = this.__isset.debugInfo;
      return tmp98;
    }

    public async global::System.Threading.Tasks.Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_startIndex = false;
        bool isset_totalNotes = false;
        bool isset_notes = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I32)
              {
                StartIndex = await iprot.ReadI32Async(cancellationToken);
                isset_startIndex = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.I32)
              {
                TotalNotes = await iprot.ReadI32Async(cancellationToken);
                isset_totalNotes = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.List)
              {
                {
                  TList _list99 = await iprot.ReadListBeginAsync(cancellationToken);
                  Notes = new List<global::Evernote.EDAM.NoteStore.NoteMetadata>(_list99.Count);
                  for(int _i100 = 0; _i100 < _list99.Count; ++_i100)
                  {
                    global::Evernote.EDAM.NoteStore.NoteMetadata _elem101;
                    _elem101 = new global::Evernote.EDAM.NoteStore.NoteMetadata();
                    await _elem101.ReadAsync(iprot, cancellationToken);
                    Notes.Add(_elem101);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
                isset_notes = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 4:
              if (field.Type == TType.List)
              {
                {
                  TList _list102 = await iprot.ReadListBeginAsync(cancellationToken);
                  StoppedWords = new List<string>(_list102.Count);
                  for(int _i103 = 0; _i103 < _list102.Count; ++_i103)
                  {
                    string _elem104;
                    _elem104 = await iprot.ReadStringAsync(cancellationToken);
                    StoppedWords.Add(_elem104);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 5:
              if (field.Type == TType.List)
              {
                {
                  TList _list105 = await iprot.ReadListBeginAsync(cancellationToken);
                  SearchedWords = new List<string>(_list105.Count);
                  for(int _i106 = 0; _i106 < _list105.Count; ++_i106)
                  {
                    string _elem107;
                    _elem107 = await iprot.ReadStringAsync(cancellationToken);
                    SearchedWords.Add(_elem107);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 6:
              if (field.Type == TType.I32)
              {
                UpdateCount = await iprot.ReadI32Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 7:
              if (field.Type == TType.String)
              {
                SearchContextBytes = await iprot.ReadBinaryAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 9:
              if (field.Type == TType.String)
              {
                DebugInfo = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_startIndex)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_totalNotes)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_notes)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async global::System.Threading.Tasks.Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var tmp108 = new TStruct("NotesMetadataList");
        await oprot.WriteStructBeginAsync(tmp108, cancellationToken);
        var tmp109 = new TField();
        tmp109.Name = "startIndex";
        tmp109.Type = TType.I32;
        tmp109.ID = 1;
        await oprot.WriteFieldBeginAsync(tmp109, cancellationToken);
        await oprot.WriteI32Async(StartIndex, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        tmp109.Name = "totalNotes";
        tmp109.Type = TType.I32;
        tmp109.ID = 2;
        await oprot.WriteFieldBeginAsync(tmp109, cancellationToken);
        await oprot.WriteI32Async(TotalNotes, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        if((Notes != null))
        {
          tmp109.Name = "notes";
          tmp109.Type = TType.List;
          tmp109.ID = 3;
          await oprot.WriteFieldBeginAsync(tmp109, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, Notes.Count), cancellationToken);
            foreach (global::Evernote.EDAM.NoteStore.NoteMetadata _iter110 in Notes)
            {
              await _iter110.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((StoppedWords != null) && __isset.stoppedWords)
        {
          tmp109.Name = "stoppedWords";
          tmp109.Type = TType.List;
          tmp109.ID = 4;
          await oprot.WriteFieldBeginAsync(tmp109, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.String, StoppedWords.Count), cancellationToken);
            foreach (string _iter111 in StoppedWords)
            {
              await oprot.WriteStringAsync(_iter111, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((SearchedWords != null) && __isset.searchedWords)
        {
          tmp109.Name = "searchedWords";
          tmp109.Type = TType.List;
          tmp109.ID = 5;
          await oprot.WriteFieldBeginAsync(tmp109, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.String, SearchedWords.Count), cancellationToken);
            foreach (string _iter112 in SearchedWords)
            {
              await oprot.WriteStringAsync(_iter112, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.updateCount)
        {
          tmp109.Name = "updateCount";
          tmp109.Type = TType.I32;
          tmp109.ID = 6;
          await oprot.WriteFieldBeginAsync(tmp109, cancellationToken);
          await oprot.WriteI32Async(UpdateCount, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((SearchContextBytes != null) && __isset.searchContextBytes)
        {
          tmp109.Name = "searchContextBytes";
          tmp109.Type = TType.String;
          tmp109.ID = 7;
          await oprot.WriteFieldBeginAsync(tmp109, cancellationToken);
          await oprot.WriteBinaryAsync(SearchContextBytes, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((DebugInfo != null) && __isset.debugInfo)
        {
          tmp109.Name = "debugInfo";
          tmp109.Type = TType.String;
          tmp109.ID = 9;
          await oprot.WriteFieldBeginAsync(tmp109, cancellationToken);
          await oprot.WriteStringAsync(DebugInfo, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      if (!(that is NotesMetadataList other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return global::System.Object.Equals(StartIndex, other.StartIndex)
        && global::System.Object.Equals(TotalNotes, other.TotalNotes)
        && TCollections.Equals(Notes, other.Notes)
        && ((__isset.stoppedWords == other.__isset.stoppedWords) && ((!__isset.stoppedWords) || (TCollections.Equals(StoppedWords, other.StoppedWords))))
        && ((__isset.searchedWords == other.__isset.searchedWords) && ((!__isset.searchedWords) || (TCollections.Equals(SearchedWords, other.SearchedWords))))
        && ((__isset.updateCount == other.__isset.updateCount) && ((!__isset.updateCount) || (global::System.Object.Equals(UpdateCount, other.UpdateCount))))
        && ((__isset.searchContextBytes == other.__isset.searchContextBytes) && ((!__isset.searchContextBytes) || (TCollections.Equals(SearchContextBytes, other.SearchContextBytes))))
        && ((__isset.debugInfo == other.__isset.debugInfo) && ((!__isset.debugInfo) || (global::System.Object.Equals(DebugInfo, other.DebugInfo))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        hashcode = (hashcode * 397) + StartIndex.GetHashCode();
        hashcode = (hashcode * 397) + TotalNotes.GetHashCode();
        if((Notes != null))
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Notes);
        }
        if((StoppedWords != null) && __isset.stoppedWords)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(StoppedWords);
        }
        if((SearchedWords != null) && __isset.searchedWords)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(SearchedWords);
        }
        if(__isset.updateCount)
        {
          hashcode = (hashcode * 397) + UpdateCount.GetHashCode();
        }
        if((SearchContextBytes != null) && __isset.searchContextBytes)
        {
          hashcode = (hashcode * 397) + SearchContextBytes.GetHashCode();
        }
        if((DebugInfo != null) && __isset.debugInfo)
        {
          hashcode = (hashcode * 397) + DebugInfo.GetHashCode();
        }
      }
      return hashcode;
    }

    public override string ToString()
    {
      var tmp113 = new StringBuilder("NotesMetadataList(");
      tmp113.Append(", StartIndex: ");
      StartIndex.ToString(tmp113);
      tmp113.Append(", TotalNotes: ");
      TotalNotes.ToString(tmp113);
      if((Notes != null))
      {
        tmp113.Append(", Notes: ");
        Notes.ToString(tmp113);
      }
      if((StoppedWords != null) && __isset.stoppedWords)
      {
        tmp113.Append(", StoppedWords: ");
        StoppedWords.ToString(tmp113);
      }
      if((SearchedWords != null) && __isset.searchedWords)
      {
        tmp113.Append(", SearchedWords: ");
        SearchedWords.ToString(tmp113);
      }
      if(__isset.updateCount)
      {
        tmp113.Append(", UpdateCount: ");
        UpdateCount.ToString(tmp113);
      }
      if((SearchContextBytes != null) && __isset.searchContextBytes)
      {
        tmp113.Append(", SearchContextBytes: ");
        SearchContextBytes.ToString(tmp113);
      }
      if((DebugInfo != null) && __isset.debugInfo)
      {
        tmp113.Append(", DebugInfo: ");
        DebugInfo.ToString(tmp113);
      }
      tmp113.Append(')');
      return tmp113.ToString();
    }
  }

}
