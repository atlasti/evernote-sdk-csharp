/**
 * <auto-generated>
 * Autogenerated by Thrift Compiler (0.16.0)
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 * </auto-generated>
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Thrift;
using Thrift.Collections;

using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;
using Thrift.Transport;
using Thrift.Transport.Client;
using Thrift.Transport.Server;
using Thrift.Processor;


#nullable disable                // suppress C# 8.0 nullable contexts (we still support earlier versions)
#pragma warning disable IDE0079  // remove unnecessary pragmas
#pragma warning disable IDE1006  // parts of the code use IDL spelling
#pragma warning disable IDE0083  // pattern matching "that is not SomeType" requires net5.0 but we still support earlier versions

namespace Evernote.EDAM.NoteStore
{

  /// <summary>
  /// The result of calling findRelated().  The contents of the notes,
  /// notebooks, and tags fields will be in decreasing order of expected
  /// relevance.  It is possible that fewer results than requested will be
  /// returned even if there are enough distinct entities in the account
  /// in cases where the relevance is estimated to be low.
  /// 
  /// <dl>
  /// <dt>notes</dt>
  /// <dd>If notes have been requested to be included, this will be the
  ///     list of notes.</dd>
  /// 
  /// <dt>notebooks</dt>
  /// <dd>If notebooks have been requested to be included, this will be the
  ///     list of notebooks.</dd>
  /// 
  /// <dt>tags</dt>
  /// <dd>If tags have been requested to be included, this will be the list
  ///     of tags.</dd>
  /// 
  /// <dt>containingNotebooks</dt>
  /// <dd>If <code>includeContainingNotebooks</code> is set to <code>true</code>
  ///     in the RelatedResultSpec, return the list of notebooks to
  ///     to which the returned related notes belong. The notebooks in this
  ///     list will occur once per notebook GUID and are represented as
  ///     NotebookDescriptor objects.</dd>
  /// 
  /// <dt>experts</dt>
  /// <dd>If experts have been requested to be included, this will return
  ///  a list of users within your business who have knowledge about the specified query.
  /// </dd>
  /// 
  /// <dt>relatedContent</dt>
  /// <dd>If related content has been requested to be included, this will be the list of
  ///  related content snippets.
  /// </dd>
  /// 
  /// <dt>cacheKey</dt>
  /// <dd>If set and non-empty, this cache key may be used in subsequent
  ///     "NoteStore.findRelated" calls (via "RelatedQuery") to re-use previous
  ///     responses that were cached on the client-side, instead of actually performing
  ///     another search.
  /// 
  ///     If set to an empty string, this indicates that the server could not determine
  ///     a specific key for this response, but the client should nevertheless remove
  ///     any previously cached result for this request.
  /// 
  ///     If unset/null, it is up to the client whether to re-use cached results or to
  ///     use the server's response.
  /// 
  ///     If set to the exact non-empty cache key that was specified in
  ///     "RelatedQuery.cacheKey", this indicates that the server decided that cached results
  ///     could be reused.
  /// 
  ///     Depending on the cache key specified in the query, the "RelatedResult" may only be
  ///     partially filled. For each set field, the client should replace the corresponding
  ///     part in the previously cached result with the new partial result.
  /// 
  ///     For example, for a specific query that has both "RelatedResultSpec.maxNotes" and
  ///     "RelatedResultSpec.maxRelatedContent" set to positive values, the server may decide
  ///     that the previously requested and cached <em>Related Content</em> are unchanged,
  ///     but new results for <em>Related Notes</em> are available. The
  ///     response will have a new cache key and have "RelatedResult.notes" set, but have
  ///     "RelatedResult.relatedContent" unset (not just empty, but really unset).
  /// 
  ///     In this situation, the client should replace any cached notes with the newly
  ///     returned "RelatedResult.notes", but it can re-use the previously cached entries for
  ///     "RelatedResult.relatedContent". List fields that are set, but empty indicate that
  ///     no results could be found; the cache should be updated correspondingly.
  /// </dd>
  /// 
  /// <dt>cacheExpires</dt>
  /// <dd> If set, clients should reuse this response for any situations where the same input
  ///      parameters are applicable for up to this many seconds after receiving this result.
  /// 
  ///      After this time has passed, the client may request a new result from the service,
  ///      but it should supply the stored cacheKey to the service when checking for an
  ///      update.
  /// </dd>
  /// 
  /// </dl>
  /// </summary>
  public partial class RelatedResult : TBase
  {
    private List<global::Evernote.EDAM.Type.Note> _notes;
    private List<global::Evernote.EDAM.Type.Notebook> _notebooks;
    private List<global::Evernote.EDAM.Type.Tag> _tags;
    private List<global::Evernote.EDAM.Type.NotebookDescriptor> _containingNotebooks;
    private string _debugInfo;
    private List<global::Evernote.EDAM.Type.UserProfile> _experts;
    private List<global::Evernote.EDAM.Type.RelatedContent> _relatedContent;
    private string _cacheKey;
    private int _cacheExpires;

    public List<global::Evernote.EDAM.Type.Note> Notes
    {
      get
      {
        return _notes;
      }
      set
      {
        __isset.notes = true;
        this._notes = value;
      }
    }

    public List<global::Evernote.EDAM.Type.Notebook> Notebooks
    {
      get
      {
        return _notebooks;
      }
      set
      {
        __isset.notebooks = true;
        this._notebooks = value;
      }
    }

    public List<global::Evernote.EDAM.Type.Tag> Tags
    {
      get
      {
        return _tags;
      }
      set
      {
        __isset.tags = true;
        this._tags = value;
      }
    }

    public List<global::Evernote.EDAM.Type.NotebookDescriptor> ContainingNotebooks
    {
      get
      {
        return _containingNotebooks;
      }
      set
      {
        __isset.containingNotebooks = true;
        this._containingNotebooks = value;
      }
    }

    public string DebugInfo
    {
      get
      {
        return _debugInfo;
      }
      set
      {
        __isset.debugInfo = true;
        this._debugInfo = value;
      }
    }

    public List<global::Evernote.EDAM.Type.UserProfile> Experts
    {
      get
      {
        return _experts;
      }
      set
      {
        __isset.experts = true;
        this._experts = value;
      }
    }

    public List<global::Evernote.EDAM.Type.RelatedContent> RelatedContent
    {
      get
      {
        return _relatedContent;
      }
      set
      {
        __isset.relatedContent = true;
        this._relatedContent = value;
      }
    }

    public string CacheKey
    {
      get
      {
        return _cacheKey;
      }
      set
      {
        __isset.cacheKey = true;
        this._cacheKey = value;
      }
    }

    public int CacheExpires
    {
      get
      {
        return _cacheExpires;
      }
      set
      {
        __isset.cacheExpires = true;
        this._cacheExpires = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool notes;
      public bool notebooks;
      public bool tags;
      public bool containingNotebooks;
      public bool debugInfo;
      public bool experts;
      public bool relatedContent;
      public bool cacheKey;
      public bool cacheExpires;
    }

    public RelatedResult()
    {
    }

    public RelatedResult DeepCopy()
    {
      var tmp163 = new RelatedResult();
      if((Notes != null) && __isset.notes)
      {
        tmp163.Notes = this.Notes.DeepCopy();
      }
      tmp163.__isset.notes = this.__isset.notes;
      if((Notebooks != null) && __isset.notebooks)
      {
        tmp163.Notebooks = this.Notebooks.DeepCopy();
      }
      tmp163.__isset.notebooks = this.__isset.notebooks;
      if((Tags != null) && __isset.tags)
      {
        tmp163.Tags = this.Tags.DeepCopy();
      }
      tmp163.__isset.tags = this.__isset.tags;
      if((ContainingNotebooks != null) && __isset.containingNotebooks)
      {
        tmp163.ContainingNotebooks = this.ContainingNotebooks.DeepCopy();
      }
      tmp163.__isset.containingNotebooks = this.__isset.containingNotebooks;
      if((DebugInfo != null) && __isset.debugInfo)
      {
        tmp163.DebugInfo = this.DebugInfo;
      }
      tmp163.__isset.debugInfo = this.__isset.debugInfo;
      if((Experts != null) && __isset.experts)
      {
        tmp163.Experts = this.Experts.DeepCopy();
      }
      tmp163.__isset.experts = this.__isset.experts;
      if((RelatedContent != null) && __isset.relatedContent)
      {
        tmp163.RelatedContent = this.RelatedContent.DeepCopy();
      }
      tmp163.__isset.relatedContent = this.__isset.relatedContent;
      if((CacheKey != null) && __isset.cacheKey)
      {
        tmp163.CacheKey = this.CacheKey;
      }
      tmp163.__isset.cacheKey = this.__isset.cacheKey;
      if(__isset.cacheExpires)
      {
        tmp163.CacheExpires = this.CacheExpires;
      }
      tmp163.__isset.cacheExpires = this.__isset.cacheExpires;
      return tmp163;
    }

    public async global::System.Threading.Tasks.Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.List)
              {
                {
                  TList _list164 = await iprot.ReadListBeginAsync(cancellationToken);
                  Notes = new List<global::Evernote.EDAM.Type.Note>(_list164.Count);
                  for(int _i165 = 0; _i165 < _list164.Count; ++_i165)
                  {
                    global::Evernote.EDAM.Type.Note _elem166;
                    _elem166 = new global::Evernote.EDAM.Type.Note();
                    await _elem166.ReadAsync(iprot, cancellationToken);
                    Notes.Add(_elem166);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.List)
              {
                {
                  TList _list167 = await iprot.ReadListBeginAsync(cancellationToken);
                  Notebooks = new List<global::Evernote.EDAM.Type.Notebook>(_list167.Count);
                  for(int _i168 = 0; _i168 < _list167.Count; ++_i168)
                  {
                    global::Evernote.EDAM.Type.Notebook _elem169;
                    _elem169 = new global::Evernote.EDAM.Type.Notebook();
                    await _elem169.ReadAsync(iprot, cancellationToken);
                    Notebooks.Add(_elem169);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.List)
              {
                {
                  TList _list170 = await iprot.ReadListBeginAsync(cancellationToken);
                  Tags = new List<global::Evernote.EDAM.Type.Tag>(_list170.Count);
                  for(int _i171 = 0; _i171 < _list170.Count; ++_i171)
                  {
                    global::Evernote.EDAM.Type.Tag _elem172;
                    _elem172 = new global::Evernote.EDAM.Type.Tag();
                    await _elem172.ReadAsync(iprot, cancellationToken);
                    Tags.Add(_elem172);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 4:
              if (field.Type == TType.List)
              {
                {
                  TList _list173 = await iprot.ReadListBeginAsync(cancellationToken);
                  ContainingNotebooks = new List<global::Evernote.EDAM.Type.NotebookDescriptor>(_list173.Count);
                  for(int _i174 = 0; _i174 < _list173.Count; ++_i174)
                  {
                    global::Evernote.EDAM.Type.NotebookDescriptor _elem175;
                    _elem175 = new global::Evernote.EDAM.Type.NotebookDescriptor();
                    await _elem175.ReadAsync(iprot, cancellationToken);
                    ContainingNotebooks.Add(_elem175);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 5:
              if (field.Type == TType.String)
              {
                DebugInfo = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 6:
              if (field.Type == TType.List)
              {
                {
                  TList _list176 = await iprot.ReadListBeginAsync(cancellationToken);
                  Experts = new List<global::Evernote.EDAM.Type.UserProfile>(_list176.Count);
                  for(int _i177 = 0; _i177 < _list176.Count; ++_i177)
                  {
                    global::Evernote.EDAM.Type.UserProfile _elem178;
                    _elem178 = new global::Evernote.EDAM.Type.UserProfile();
                    await _elem178.ReadAsync(iprot, cancellationToken);
                    Experts.Add(_elem178);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 7:
              if (field.Type == TType.List)
              {
                {
                  TList _list179 = await iprot.ReadListBeginAsync(cancellationToken);
                  RelatedContent = new List<global::Evernote.EDAM.Type.RelatedContent>(_list179.Count);
                  for(int _i180 = 0; _i180 < _list179.Count; ++_i180)
                  {
                    global::Evernote.EDAM.Type.RelatedContent _elem181;
                    _elem181 = new global::Evernote.EDAM.Type.RelatedContent();
                    await _elem181.ReadAsync(iprot, cancellationToken);
                    RelatedContent.Add(_elem181);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 8:
              if (field.Type == TType.String)
              {
                CacheKey = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 9:
              if (field.Type == TType.I32)
              {
                CacheExpires = await iprot.ReadI32Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async global::System.Threading.Tasks.Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var tmp182 = new TStruct("RelatedResult");
        await oprot.WriteStructBeginAsync(tmp182, cancellationToken);
        var tmp183 = new TField();
        if((Notes != null) && __isset.notes)
        {
          tmp183.Name = "notes";
          tmp183.Type = TType.List;
          tmp183.ID = 1;
          await oprot.WriteFieldBeginAsync(tmp183, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, Notes.Count), cancellationToken);
            foreach (global::Evernote.EDAM.Type.Note _iter184 in Notes)
            {
              await _iter184.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Notebooks != null) && __isset.notebooks)
        {
          tmp183.Name = "notebooks";
          tmp183.Type = TType.List;
          tmp183.ID = 2;
          await oprot.WriteFieldBeginAsync(tmp183, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, Notebooks.Count), cancellationToken);
            foreach (global::Evernote.EDAM.Type.Notebook _iter185 in Notebooks)
            {
              await _iter185.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Tags != null) && __isset.tags)
        {
          tmp183.Name = "tags";
          tmp183.Type = TType.List;
          tmp183.ID = 3;
          await oprot.WriteFieldBeginAsync(tmp183, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, Tags.Count), cancellationToken);
            foreach (global::Evernote.EDAM.Type.Tag _iter186 in Tags)
            {
              await _iter186.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((ContainingNotebooks != null) && __isset.containingNotebooks)
        {
          tmp183.Name = "containingNotebooks";
          tmp183.Type = TType.List;
          tmp183.ID = 4;
          await oprot.WriteFieldBeginAsync(tmp183, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, ContainingNotebooks.Count), cancellationToken);
            foreach (global::Evernote.EDAM.Type.NotebookDescriptor _iter187 in ContainingNotebooks)
            {
              await _iter187.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((DebugInfo != null) && __isset.debugInfo)
        {
          tmp183.Name = "debugInfo";
          tmp183.Type = TType.String;
          tmp183.ID = 5;
          await oprot.WriteFieldBeginAsync(tmp183, cancellationToken);
          await oprot.WriteStringAsync(DebugInfo, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Experts != null) && __isset.experts)
        {
          tmp183.Name = "experts";
          tmp183.Type = TType.List;
          tmp183.ID = 6;
          await oprot.WriteFieldBeginAsync(tmp183, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, Experts.Count), cancellationToken);
            foreach (global::Evernote.EDAM.Type.UserProfile _iter188 in Experts)
            {
              await _iter188.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((RelatedContent != null) && __isset.relatedContent)
        {
          tmp183.Name = "relatedContent";
          tmp183.Type = TType.List;
          tmp183.ID = 7;
          await oprot.WriteFieldBeginAsync(tmp183, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, RelatedContent.Count), cancellationToken);
            foreach (global::Evernote.EDAM.Type.RelatedContent _iter189 in RelatedContent)
            {
              await _iter189.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((CacheKey != null) && __isset.cacheKey)
        {
          tmp183.Name = "cacheKey";
          tmp183.Type = TType.String;
          tmp183.ID = 8;
          await oprot.WriteFieldBeginAsync(tmp183, cancellationToken);
          await oprot.WriteStringAsync(CacheKey, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.cacheExpires)
        {
          tmp183.Name = "cacheExpires";
          tmp183.Type = TType.I32;
          tmp183.ID = 9;
          await oprot.WriteFieldBeginAsync(tmp183, cancellationToken);
          await oprot.WriteI32Async(CacheExpires, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      if (!(that is RelatedResult other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.notes == other.__isset.notes) && ((!__isset.notes) || (TCollections.Equals(Notes, other.Notes))))
        && ((__isset.notebooks == other.__isset.notebooks) && ((!__isset.notebooks) || (TCollections.Equals(Notebooks, other.Notebooks))))
        && ((__isset.tags == other.__isset.tags) && ((!__isset.tags) || (TCollections.Equals(Tags, other.Tags))))
        && ((__isset.containingNotebooks == other.__isset.containingNotebooks) && ((!__isset.containingNotebooks) || (TCollections.Equals(ContainingNotebooks, other.ContainingNotebooks))))
        && ((__isset.debugInfo == other.__isset.debugInfo) && ((!__isset.debugInfo) || (global::System.Object.Equals(DebugInfo, other.DebugInfo))))
        && ((__isset.experts == other.__isset.experts) && ((!__isset.experts) || (TCollections.Equals(Experts, other.Experts))))
        && ((__isset.relatedContent == other.__isset.relatedContent) && ((!__isset.relatedContent) || (TCollections.Equals(RelatedContent, other.RelatedContent))))
        && ((__isset.cacheKey == other.__isset.cacheKey) && ((!__isset.cacheKey) || (global::System.Object.Equals(CacheKey, other.CacheKey))))
        && ((__isset.cacheExpires == other.__isset.cacheExpires) && ((!__isset.cacheExpires) || (global::System.Object.Equals(CacheExpires, other.CacheExpires))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if((Notes != null) && __isset.notes)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Notes);
        }
        if((Notebooks != null) && __isset.notebooks)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Notebooks);
        }
        if((Tags != null) && __isset.tags)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Tags);
        }
        if((ContainingNotebooks != null) && __isset.containingNotebooks)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(ContainingNotebooks);
        }
        if((DebugInfo != null) && __isset.debugInfo)
        {
          hashcode = (hashcode * 397) + DebugInfo.GetHashCode();
        }
        if((Experts != null) && __isset.experts)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Experts);
        }
        if((RelatedContent != null) && __isset.relatedContent)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(RelatedContent);
        }
        if((CacheKey != null) && __isset.cacheKey)
        {
          hashcode = (hashcode * 397) + CacheKey.GetHashCode();
        }
        if(__isset.cacheExpires)
        {
          hashcode = (hashcode * 397) + CacheExpires.GetHashCode();
        }
      }
      return hashcode;
    }

    public override string ToString()
    {
      var tmp190 = new StringBuilder("RelatedResult(");
      int tmp191 = 0;
      if((Notes != null) && __isset.notes)
      {
        if(0 < tmp191++) { tmp190.Append(", "); }
        tmp190.Append("Notes: ");
        Notes.ToString(tmp190);
      }
      if((Notebooks != null) && __isset.notebooks)
      {
        if(0 < tmp191++) { tmp190.Append(", "); }
        tmp190.Append("Notebooks: ");
        Notebooks.ToString(tmp190);
      }
      if((Tags != null) && __isset.tags)
      {
        if(0 < tmp191++) { tmp190.Append(", "); }
        tmp190.Append("Tags: ");
        Tags.ToString(tmp190);
      }
      if((ContainingNotebooks != null) && __isset.containingNotebooks)
      {
        if(0 < tmp191++) { tmp190.Append(", "); }
        tmp190.Append("ContainingNotebooks: ");
        ContainingNotebooks.ToString(tmp190);
      }
      if((DebugInfo != null) && __isset.debugInfo)
      {
        if(0 < tmp191++) { tmp190.Append(", "); }
        tmp190.Append("DebugInfo: ");
        DebugInfo.ToString(tmp190);
      }
      if((Experts != null) && __isset.experts)
      {
        if(0 < tmp191++) { tmp190.Append(", "); }
        tmp190.Append("Experts: ");
        Experts.ToString(tmp190);
      }
      if((RelatedContent != null) && __isset.relatedContent)
      {
        if(0 < tmp191++) { tmp190.Append(", "); }
        tmp190.Append("RelatedContent: ");
        RelatedContent.ToString(tmp190);
      }
      if((CacheKey != null) && __isset.cacheKey)
      {
        if(0 < tmp191++) { tmp190.Append(", "); }
        tmp190.Append("CacheKey: ");
        CacheKey.ToString(tmp190);
      }
      if(__isset.cacheExpires)
      {
        if(0 < tmp191++) { tmp190.Append(", "); }
        tmp190.Append("CacheExpires: ");
        CacheExpires.ToString(tmp190);
      }
      tmp190.Append(')');
      return tmp190.ToString();
    }
  }

}
