/**
 * <auto-generated>
 * Autogenerated by Thrift Compiler (0.16.0)
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 * </auto-generated>
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Thrift;
using Thrift.Collections;

using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;
using Thrift.Transport;
using Thrift.Transport.Client;
using Thrift.Transport.Server;
using Thrift.Processor;


#nullable disable                // suppress C# 8.0 nullable contexts (we still support earlier versions)
#pragma warning disable IDE0079  // remove unnecessary pragmas
#pragma warning disable IDE1006  // parts of the code use IDL spelling
#pragma warning disable IDE0083  // pattern matching "that is not SomeType" requires net5.0 but we still support earlier versions

namespace Evernote.EDAM.NoteStore
{

  /// <summary>
  ///  A small structure for returning a list of notes out of a larger set.
  /// 
  /// <dl>
  ///  <dt>startIndex</dt>
  ///    <dd>
  ///    The starting index within the overall set of notes.  This
  ///    is also the number of notes that are "before" this list in the set.
  ///    </dd>
  /// 
  ///  <dt>totalNotes</dt>
  ///    <dd>
  ///    The number of notes in the larger set.  This can be used
  ///    to calculate how many notes are "after" this note in the set.
  ///    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
  ///    </dd>
  /// 
  ///  <dt>notes</dt>
  ///    <dd>
  ///    The list of notes from this range.  The Notes will include all
  ///    metadata (attributes, resources, etc.), but will not include the ENML
  ///    content of the note or the binary contents of any resources.
  ///    </dd>
  /// 
  ///  <dt>stoppedWords</dt>
  ///    <dd>
  ///    If the NoteList was produced using a text based search
  ///    query that included words that are not indexed or searched by the service,
  ///    this will include a list of those ignored words.
  ///    </dd>
  /// 
  ///  <dt>searchedWords</dt>
  ///    <dd>
  ///    If the NoteList was produced using a text based search
  ///    query that included viable search words or quoted expressions, this will
  ///    include a list of those words.  Any stopped words will not be included
  ///    in this list.
  ///    </dd>
  /// 
  ///  <dt>updateCount</dt>
  ///    <dd>
  ///    Indicates the total number of transactions that have
  ///    been committed within the account.  This reflects (for example) the
  ///    number of discrete additions or modifications that have been made to
  ///    the data in this account (tags, notes, resources, etc.).
  ///    This number is the "high water mark" for Update Sequence Numbers (USN)
  ///    within the account.
  ///    </dd>
  /// 
  ///  <dt>searchContextBytes</dt>
  ///    <dd>
  ///    Specifies the correlating information about the current search session, in byte array.
  ///    </dd>
  ///  </dl>
  /// 
  ///  <dt>debugInfo</dt>
  ///    <dd>
  ///    Depends on the value of <code>context</code> in NoteFilter, this field
  ///    may contain debug information if the service decides to do so.
  ///    </dd>
  /// 
  /// </summary>
  public partial class NoteList : TBase
  {
    private List<string> _stoppedWords;
    private List<string> _searchedWords;
    private int _updateCount;
    private byte[] _searchContextBytes;
    private string _debugInfo;

    public int StartIndex { get; set; }

    public int TotalNotes { get; set; }

    public List<global::Evernote.EDAM.Type.Note> Notes { get; set; }

    public List<string> StoppedWords
    {
      get
      {
        return _stoppedWords;
      }
      set
      {
        __isset.stoppedWords = true;
        this._stoppedWords = value;
      }
    }

    public List<string> SearchedWords
    {
      get
      {
        return _searchedWords;
      }
      set
      {
        __isset.searchedWords = true;
        this._searchedWords = value;
      }
    }

    public int UpdateCount
    {
      get
      {
        return _updateCount;
      }
      set
      {
        __isset.updateCount = true;
        this._updateCount = value;
      }
    }

    public byte[] SearchContextBytes
    {
      get
      {
        return _searchContextBytes;
      }
      set
      {
        __isset.searchContextBytes = true;
        this._searchContextBytes = value;
      }
    }

    public string DebugInfo
    {
      get
      {
        return _debugInfo;
      }
      set
      {
        __isset.debugInfo = true;
        this._debugInfo = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool stoppedWords;
      public bool searchedWords;
      public bool updateCount;
      public bool searchContextBytes;
      public bool debugInfo;
    }

    public NoteList()
    {
    }

    public NoteList(int startIndex, int totalNotes, List<global::Evernote.EDAM.Type.Note> notes) : this()
    {
      this.StartIndex = startIndex;
      this.TotalNotes = totalNotes;
      this.Notes = notes;
    }

    public NoteList DeepCopy()
    {
      var tmp72 = new NoteList();
      tmp72.StartIndex = this.StartIndex;
      tmp72.TotalNotes = this.TotalNotes;
      if((Notes != null))
      {
        tmp72.Notes = this.Notes.DeepCopy();
      }
      if((StoppedWords != null) && __isset.stoppedWords)
      {
        tmp72.StoppedWords = this.StoppedWords.DeepCopy();
      }
      tmp72.__isset.stoppedWords = this.__isset.stoppedWords;
      if((SearchedWords != null) && __isset.searchedWords)
      {
        tmp72.SearchedWords = this.SearchedWords.DeepCopy();
      }
      tmp72.__isset.searchedWords = this.__isset.searchedWords;
      if(__isset.updateCount)
      {
        tmp72.UpdateCount = this.UpdateCount;
      }
      tmp72.__isset.updateCount = this.__isset.updateCount;
      if((SearchContextBytes != null) && __isset.searchContextBytes)
      {
        tmp72.SearchContextBytes = this.SearchContextBytes.ToArray();
      }
      tmp72.__isset.searchContextBytes = this.__isset.searchContextBytes;
      if((DebugInfo != null) && __isset.debugInfo)
      {
        tmp72.DebugInfo = this.DebugInfo;
      }
      tmp72.__isset.debugInfo = this.__isset.debugInfo;
      return tmp72;
    }

    public async global::System.Threading.Tasks.Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_startIndex = false;
        bool isset_totalNotes = false;
        bool isset_notes = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I32)
              {
                StartIndex = await iprot.ReadI32Async(cancellationToken);
                isset_startIndex = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.I32)
              {
                TotalNotes = await iprot.ReadI32Async(cancellationToken);
                isset_totalNotes = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.List)
              {
                {
                  TList _list73 = await iprot.ReadListBeginAsync(cancellationToken);
                  Notes = new List<global::Evernote.EDAM.Type.Note>(_list73.Count);
                  for(int _i74 = 0; _i74 < _list73.Count; ++_i74)
                  {
                    global::Evernote.EDAM.Type.Note _elem75;
                    _elem75 = new global::Evernote.EDAM.Type.Note();
                    await _elem75.ReadAsync(iprot, cancellationToken);
                    Notes.Add(_elem75);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
                isset_notes = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 4:
              if (field.Type == TType.List)
              {
                {
                  TList _list76 = await iprot.ReadListBeginAsync(cancellationToken);
                  StoppedWords = new List<string>(_list76.Count);
                  for(int _i77 = 0; _i77 < _list76.Count; ++_i77)
                  {
                    string _elem78;
                    _elem78 = await iprot.ReadStringAsync(cancellationToken);
                    StoppedWords.Add(_elem78);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 5:
              if (field.Type == TType.List)
              {
                {
                  TList _list79 = await iprot.ReadListBeginAsync(cancellationToken);
                  SearchedWords = new List<string>(_list79.Count);
                  for(int _i80 = 0; _i80 < _list79.Count; ++_i80)
                  {
                    string _elem81;
                    _elem81 = await iprot.ReadStringAsync(cancellationToken);
                    SearchedWords.Add(_elem81);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 6:
              if (field.Type == TType.I32)
              {
                UpdateCount = await iprot.ReadI32Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 7:
              if (field.Type == TType.String)
              {
                SearchContextBytes = await iprot.ReadBinaryAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 8:
              if (field.Type == TType.String)
              {
                DebugInfo = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_startIndex)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_totalNotes)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_notes)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async global::System.Threading.Tasks.Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var tmp82 = new TStruct("NoteList");
        await oprot.WriteStructBeginAsync(tmp82, cancellationToken);
        var tmp83 = new TField();
        tmp83.Name = "startIndex";
        tmp83.Type = TType.I32;
        tmp83.ID = 1;
        await oprot.WriteFieldBeginAsync(tmp83, cancellationToken);
        await oprot.WriteI32Async(StartIndex, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        tmp83.Name = "totalNotes";
        tmp83.Type = TType.I32;
        tmp83.ID = 2;
        await oprot.WriteFieldBeginAsync(tmp83, cancellationToken);
        await oprot.WriteI32Async(TotalNotes, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        if((Notes != null))
        {
          tmp83.Name = "notes";
          tmp83.Type = TType.List;
          tmp83.ID = 3;
          await oprot.WriteFieldBeginAsync(tmp83, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, Notes.Count), cancellationToken);
            foreach (global::Evernote.EDAM.Type.Note _iter84 in Notes)
            {
              await _iter84.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((StoppedWords != null) && __isset.stoppedWords)
        {
          tmp83.Name = "stoppedWords";
          tmp83.Type = TType.List;
          tmp83.ID = 4;
          await oprot.WriteFieldBeginAsync(tmp83, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.String, StoppedWords.Count), cancellationToken);
            foreach (string _iter85 in StoppedWords)
            {
              await oprot.WriteStringAsync(_iter85, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((SearchedWords != null) && __isset.searchedWords)
        {
          tmp83.Name = "searchedWords";
          tmp83.Type = TType.List;
          tmp83.ID = 5;
          await oprot.WriteFieldBeginAsync(tmp83, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.String, SearchedWords.Count), cancellationToken);
            foreach (string _iter86 in SearchedWords)
            {
              await oprot.WriteStringAsync(_iter86, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.updateCount)
        {
          tmp83.Name = "updateCount";
          tmp83.Type = TType.I32;
          tmp83.ID = 6;
          await oprot.WriteFieldBeginAsync(tmp83, cancellationToken);
          await oprot.WriteI32Async(UpdateCount, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((SearchContextBytes != null) && __isset.searchContextBytes)
        {
          tmp83.Name = "searchContextBytes";
          tmp83.Type = TType.String;
          tmp83.ID = 7;
          await oprot.WriteFieldBeginAsync(tmp83, cancellationToken);
          await oprot.WriteBinaryAsync(SearchContextBytes, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((DebugInfo != null) && __isset.debugInfo)
        {
          tmp83.Name = "debugInfo";
          tmp83.Type = TType.String;
          tmp83.ID = 8;
          await oprot.WriteFieldBeginAsync(tmp83, cancellationToken);
          await oprot.WriteStringAsync(DebugInfo, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      if (!(that is NoteList other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return global::System.Object.Equals(StartIndex, other.StartIndex)
        && global::System.Object.Equals(TotalNotes, other.TotalNotes)
        && TCollections.Equals(Notes, other.Notes)
        && ((__isset.stoppedWords == other.__isset.stoppedWords) && ((!__isset.stoppedWords) || (TCollections.Equals(StoppedWords, other.StoppedWords))))
        && ((__isset.searchedWords == other.__isset.searchedWords) && ((!__isset.searchedWords) || (TCollections.Equals(SearchedWords, other.SearchedWords))))
        && ((__isset.updateCount == other.__isset.updateCount) && ((!__isset.updateCount) || (global::System.Object.Equals(UpdateCount, other.UpdateCount))))
        && ((__isset.searchContextBytes == other.__isset.searchContextBytes) && ((!__isset.searchContextBytes) || (TCollections.Equals(SearchContextBytes, other.SearchContextBytes))))
        && ((__isset.debugInfo == other.__isset.debugInfo) && ((!__isset.debugInfo) || (global::System.Object.Equals(DebugInfo, other.DebugInfo))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        hashcode = (hashcode * 397) + StartIndex.GetHashCode();
        hashcode = (hashcode * 397) + TotalNotes.GetHashCode();
        if((Notes != null))
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Notes);
        }
        if((StoppedWords != null) && __isset.stoppedWords)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(StoppedWords);
        }
        if((SearchedWords != null) && __isset.searchedWords)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(SearchedWords);
        }
        if(__isset.updateCount)
        {
          hashcode = (hashcode * 397) + UpdateCount.GetHashCode();
        }
        if((SearchContextBytes != null) && __isset.searchContextBytes)
        {
          hashcode = (hashcode * 397) + SearchContextBytes.GetHashCode();
        }
        if((DebugInfo != null) && __isset.debugInfo)
        {
          hashcode = (hashcode * 397) + DebugInfo.GetHashCode();
        }
      }
      return hashcode;
    }

    public override string ToString()
    {
      var tmp87 = new StringBuilder("NoteList(");
      tmp87.Append(", StartIndex: ");
      StartIndex.ToString(tmp87);
      tmp87.Append(", TotalNotes: ");
      TotalNotes.ToString(tmp87);
      if((Notes != null))
      {
        tmp87.Append(", Notes: ");
        Notes.ToString(tmp87);
      }
      if((StoppedWords != null) && __isset.stoppedWords)
      {
        tmp87.Append(", StoppedWords: ");
        StoppedWords.ToString(tmp87);
      }
      if((SearchedWords != null) && __isset.searchedWords)
      {
        tmp87.Append(", SearchedWords: ");
        SearchedWords.ToString(tmp87);
      }
      if(__isset.updateCount)
      {
        tmp87.Append(", UpdateCount: ");
        UpdateCount.ToString(tmp87);
      }
      if((SearchContextBytes != null) && __isset.searchContextBytes)
      {
        tmp87.Append(", SearchContextBytes: ");
        SearchContextBytes.ToString(tmp87);
      }
      if((DebugInfo != null) && __isset.debugInfo)
      {
        tmp87.Append(", DebugInfo: ");
        DebugInfo.ToString(tmp87);
      }
      tmp87.Append(')');
      return tmp87.ToString();
    }
  }

}
