/**
 * <auto-generated>
 * Autogenerated by Thrift Compiler (0.16.0)
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 * </auto-generated>
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Thrift;
using Thrift.Collections;

using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;
using Thrift.Transport;
using Thrift.Transport.Client;
using Thrift.Transport.Server;
using Thrift.Processor;


#nullable disable                // suppress C# 8.0 nullable contexts (we still support earlier versions)
#pragma warning disable IDE0079  // remove unnecessary pragmas
#pragma warning disable IDE1006  // parts of the code use IDL spelling
#pragma warning disable IDE0083  // pattern matching "that is not SomeType" requires net5.0 but we still support earlier versions

namespace Evernote.EDAM.NoteStore
{

  /// <summary>
  ///  A list of criteria that are used to indicate which notes are desired from
  ///  the account.  This is used in queries to the NoteStore to determine
  ///  which notes should be retrieved.
  /// 
  /// <dl>
  ///  <dt>order</dt>
  ///    <dd>
  ///    The NoteSortOrder value indicating what criterion should be
  ///    used to sort the results of the filter.
  ///    </dd>
  /// 
  ///  <dt>ascending</dt>
  ///    <dd>
  ///    If true, the results will be ascending in the requested
  ///    sort order.  If false, the results will be descending.
  ///    </dd>
  /// 
  ///  <dt>words</dt>
  ///    <dd>
  ///    If present, a search query string that will filter the set of notes to be returned.
  ///    Accepts the full search grammar documented in the Evernote API Overview.
  ///    </dd>
  /// 
  ///  <dt>notebookGuid</dt>
  ///    <dd>
  ///    If present, the Guid of the notebook that must contain
  ///    the notes.
  ///    </dd>
  /// 
  ///  <dt>tagGuids</dt>
  ///    <dd>
  ///    If present, the list of tags (by GUID) that must be present
  ///    on the notes.
  ///    </dd>
  /// 
  ///  <dt>timeZone</dt>
  ///    <dd>
  ///    The zone ID for the user, which will be used to interpret
  ///    any dates or times in the queries that do not include their desired zone
  ///    information.
  ///    For example, if a query requests notes created "yesterday", this
  ///    will be evaluated from the provided time zone, if provided.
  ///    The format must be encoded as a standard zone ID such as
  ///    "America/Los_Angeles".
  ///    </dd>
  /// 
  ///  <dt>inactive</dt>
  ///    <dd>
  ///    If true, then only notes that are not active (i.e. notes in
  ///    the Trash) will be returned. Otherwise, only active notes will be returned.
  ///    There is no way to find both active and inactive notes in a single query.
  ///    </dd>
  /// 
  ///  <dt>emphasized</dt>
  ///    <dd>
  ///    If present, a search query string that may or may not influence the notes
  ///    to be returned, both in terms of coverage as well as of order. Think of it
  ///    as a wish list, not a requirement.
  ///    Accepts the full search grammar documented in the Evernote API Overview.
  ///    </dd>
  /// 
  ///  <dt>includeAllReadableNotebooks</dt>
  ///    <dd>
  ///    If true, then the search will include all business notebooks that are readable
  ///    by the user. A business authentication token must be supplied for
  ///    this option to take effect when calling search APIs.
  ///    </dd>
  /// 
  ///  <dt>includeAllReadableWorkspaces</dt>
  ///    <dd>
  ///    If true, then the search will include all workspaces that are readable
  ///    by the user. A business authentication token must be supplied for
  ///    this option to take effect when calling search APIs.
  ///    </dd>
  /// 
  ///  <dt>context</dt>
  ///    <dd>
  ///    Specifies the context to consider when determining result ranking.
  ///    Clients must leave this value unset unless they wish to explicitly specify a known
  ///    non-default context.
  ///    </dd>
  /// 
  ///  <dt>rawWords</dt>
  ///    <dd>
  ///    If present, the raw user query input.
  ///    Accepts the full search grammar documented in the Evernote API Overview.
  ///    </dd>
  /// 
  ///  <dt>searchContextBytes</dt>
  ///    <dd>
  ///    Specifies the correlating information about the current search session, in byte array.
  ///    If this request is not for the first page of search results, the client should populate
  ///    this field with the value of searchContextBytes from the NotesMetadataList of the
  ///    original search response.
  ///    </dd>
  ///  </dl>
  /// </summary>
  public partial class NoteFilter : TBase
  {
    private int _order;
    private bool _ascending;
    private string _words;
    private string _notebookGuid;
    private List<string> _tagGuids;
    private string _timeZone;
    private bool _inactive;
    private string _emphasized;
    private bool _includeAllReadableNotebooks;
    private bool _includeAllReadableWorkspaces;
    private string _context;
    private string _rawWords;
    private byte[] _searchContextBytes;

    public int Order
    {
      get
      {
        return _order;
      }
      set
      {
        __isset.order = true;
        this._order = value;
      }
    }

    public bool Ascending
    {
      get
      {
        return _ascending;
      }
      set
      {
        __isset.@ascending = true;
        this._ascending = value;
      }
    }

    public string Words
    {
      get
      {
        return _words;
      }
      set
      {
        __isset.words = true;
        this._words = value;
      }
    }

    public string NotebookGuid
    {
      get
      {
        return _notebookGuid;
      }
      set
      {
        __isset.notebookGuid = true;
        this._notebookGuid = value;
      }
    }

    public List<string> TagGuids
    {
      get
      {
        return _tagGuids;
      }
      set
      {
        __isset.tagGuids = true;
        this._tagGuids = value;
      }
    }

    public string TimeZone
    {
      get
      {
        return _timeZone;
      }
      set
      {
        __isset.timeZone = true;
        this._timeZone = value;
      }
    }

    public bool Inactive
    {
      get
      {
        return _inactive;
      }
      set
      {
        __isset.inactive = true;
        this._inactive = value;
      }
    }

    public string Emphasized
    {
      get
      {
        return _emphasized;
      }
      set
      {
        __isset.emphasized = true;
        this._emphasized = value;
      }
    }

    public bool IncludeAllReadableNotebooks
    {
      get
      {
        return _includeAllReadableNotebooks;
      }
      set
      {
        __isset.includeAllReadableNotebooks = true;
        this._includeAllReadableNotebooks = value;
      }
    }

    public bool IncludeAllReadableWorkspaces
    {
      get
      {
        return _includeAllReadableWorkspaces;
      }
      set
      {
        __isset.includeAllReadableWorkspaces = true;
        this._includeAllReadableWorkspaces = value;
      }
    }

    public string Context
    {
      get
      {
        return _context;
      }
      set
      {
        __isset.context = true;
        this._context = value;
      }
    }

    public string RawWords
    {
      get
      {
        return _rawWords;
      }
      set
      {
        __isset.rawWords = true;
        this._rawWords = value;
      }
    }

    public byte[] SearchContextBytes
    {
      get
      {
        return _searchContextBytes;
      }
      set
      {
        __isset.searchContextBytes = true;
        this._searchContextBytes = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool order;
      public bool @ascending;
      public bool words;
      public bool notebookGuid;
      public bool tagGuids;
      public bool timeZone;
      public bool inactive;
      public bool emphasized;
      public bool includeAllReadableNotebooks;
      public bool includeAllReadableWorkspaces;
      public bool context;
      public bool rawWords;
      public bool searchContextBytes;
    }

    public NoteFilter()
    {
    }

    public NoteFilter DeepCopy()
    {
      var tmp63 = new NoteFilter();
      if(__isset.order)
      {
        tmp63.Order = this.Order;
      }
      tmp63.__isset.order = this.__isset.order;
      if(__isset.@ascending)
      {
        tmp63.Ascending = this.Ascending;
      }
      tmp63.__isset.@ascending = this.__isset.@ascending;
      if((Words != null) && __isset.words)
      {
        tmp63.Words = this.Words;
      }
      tmp63.__isset.words = this.__isset.words;
      if((NotebookGuid != null) && __isset.notebookGuid)
      {
        tmp63.NotebookGuid = this.NotebookGuid;
      }
      tmp63.__isset.notebookGuid = this.__isset.notebookGuid;
      if((TagGuids != null) && __isset.tagGuids)
      {
        tmp63.TagGuids = this.TagGuids.DeepCopy();
      }
      tmp63.__isset.tagGuids = this.__isset.tagGuids;
      if((TimeZone != null) && __isset.timeZone)
      {
        tmp63.TimeZone = this.TimeZone;
      }
      tmp63.__isset.timeZone = this.__isset.timeZone;
      if(__isset.inactive)
      {
        tmp63.Inactive = this.Inactive;
      }
      tmp63.__isset.inactive = this.__isset.inactive;
      if((Emphasized != null) && __isset.emphasized)
      {
        tmp63.Emphasized = this.Emphasized;
      }
      tmp63.__isset.emphasized = this.__isset.emphasized;
      if(__isset.includeAllReadableNotebooks)
      {
        tmp63.IncludeAllReadableNotebooks = this.IncludeAllReadableNotebooks;
      }
      tmp63.__isset.includeAllReadableNotebooks = this.__isset.includeAllReadableNotebooks;
      if(__isset.includeAllReadableWorkspaces)
      {
        tmp63.IncludeAllReadableWorkspaces = this.IncludeAllReadableWorkspaces;
      }
      tmp63.__isset.includeAllReadableWorkspaces = this.__isset.includeAllReadableWorkspaces;
      if((Context != null) && __isset.context)
      {
        tmp63.Context = this.Context;
      }
      tmp63.__isset.context = this.__isset.context;
      if((RawWords != null) && __isset.rawWords)
      {
        tmp63.RawWords = this.RawWords;
      }
      tmp63.__isset.rawWords = this.__isset.rawWords;
      if((SearchContextBytes != null) && __isset.searchContextBytes)
      {
        tmp63.SearchContextBytes = this.SearchContextBytes.ToArray();
      }
      tmp63.__isset.searchContextBytes = this.__isset.searchContextBytes;
      return tmp63;
    }

    public async global::System.Threading.Tasks.Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I32)
              {
                Order = await iprot.ReadI32Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Bool)
              {
                Ascending = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.String)
              {
                Words = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 4:
              if (field.Type == TType.String)
              {
                NotebookGuid = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 5:
              if (field.Type == TType.List)
              {
                {
                  TList _list64 = await iprot.ReadListBeginAsync(cancellationToken);
                  TagGuids = new List<string>(_list64.Count);
                  for(int _i65 = 0; _i65 < _list64.Count; ++_i65)
                  {
                    string _elem66;
                    _elem66 = await iprot.ReadStringAsync(cancellationToken);
                    TagGuids.Add(_elem66);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 6:
              if (field.Type == TType.String)
              {
                TimeZone = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 7:
              if (field.Type == TType.Bool)
              {
                Inactive = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 8:
              if (field.Type == TType.String)
              {
                Emphasized = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 9:
              if (field.Type == TType.Bool)
              {
                IncludeAllReadableNotebooks = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 15:
              if (field.Type == TType.Bool)
              {
                IncludeAllReadableWorkspaces = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 10:
              if (field.Type == TType.String)
              {
                Context = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 11:
              if (field.Type == TType.String)
              {
                RawWords = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 12:
              if (field.Type == TType.String)
              {
                SearchContextBytes = await iprot.ReadBinaryAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async global::System.Threading.Tasks.Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var tmp67 = new TStruct("NoteFilter");
        await oprot.WriteStructBeginAsync(tmp67, cancellationToken);
        var tmp68 = new TField();
        if(__isset.order)
        {
          tmp68.Name = "order";
          tmp68.Type = TType.I32;
          tmp68.ID = 1;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteI32Async(Order, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.@ascending)
        {
          tmp68.Name = "ascending";
          tmp68.Type = TType.Bool;
          tmp68.ID = 2;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteBoolAsync(Ascending, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Words != null) && __isset.words)
        {
          tmp68.Name = "words";
          tmp68.Type = TType.String;
          tmp68.ID = 3;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteStringAsync(Words, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((NotebookGuid != null) && __isset.notebookGuid)
        {
          tmp68.Name = "notebookGuid";
          tmp68.Type = TType.String;
          tmp68.ID = 4;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteStringAsync(NotebookGuid, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((TagGuids != null) && __isset.tagGuids)
        {
          tmp68.Name = "tagGuids";
          tmp68.Type = TType.List;
          tmp68.ID = 5;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.String, TagGuids.Count), cancellationToken);
            foreach (string _iter69 in TagGuids)
            {
              await oprot.WriteStringAsync(_iter69, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((TimeZone != null) && __isset.timeZone)
        {
          tmp68.Name = "timeZone";
          tmp68.Type = TType.String;
          tmp68.ID = 6;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteStringAsync(TimeZone, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.inactive)
        {
          tmp68.Name = "inactive";
          tmp68.Type = TType.Bool;
          tmp68.ID = 7;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteBoolAsync(Inactive, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Emphasized != null) && __isset.emphasized)
        {
          tmp68.Name = "emphasized";
          tmp68.Type = TType.String;
          tmp68.ID = 8;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteStringAsync(Emphasized, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.includeAllReadableNotebooks)
        {
          tmp68.Name = "includeAllReadableNotebooks";
          tmp68.Type = TType.Bool;
          tmp68.ID = 9;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteBoolAsync(IncludeAllReadableNotebooks, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((Context != null) && __isset.context)
        {
          tmp68.Name = "context";
          tmp68.Type = TType.String;
          tmp68.ID = 10;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteStringAsync(Context, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((RawWords != null) && __isset.rawWords)
        {
          tmp68.Name = "rawWords";
          tmp68.Type = TType.String;
          tmp68.ID = 11;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteStringAsync(RawWords, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if((SearchContextBytes != null) && __isset.searchContextBytes)
        {
          tmp68.Name = "searchContextBytes";
          tmp68.Type = TType.String;
          tmp68.ID = 12;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteBinaryAsync(SearchContextBytes, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if(__isset.includeAllReadableWorkspaces)
        {
          tmp68.Name = "includeAllReadableWorkspaces";
          tmp68.Type = TType.Bool;
          tmp68.ID = 15;
          await oprot.WriteFieldBeginAsync(tmp68, cancellationToken);
          await oprot.WriteBoolAsync(IncludeAllReadableWorkspaces, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      if (!(that is NoteFilter other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.order == other.__isset.order) && ((!__isset.order) || (global::System.Object.Equals(Order, other.Order))))
        && ((__isset.@ascending == other.__isset.@ascending) && ((!__isset.@ascending) || (global::System.Object.Equals(Ascending, other.Ascending))))
        && ((__isset.words == other.__isset.words) && ((!__isset.words) || (global::System.Object.Equals(Words, other.Words))))
        && ((__isset.notebookGuid == other.__isset.notebookGuid) && ((!__isset.notebookGuid) || (global::System.Object.Equals(NotebookGuid, other.NotebookGuid))))
        && ((__isset.tagGuids == other.__isset.tagGuids) && ((!__isset.tagGuids) || (TCollections.Equals(TagGuids, other.TagGuids))))
        && ((__isset.timeZone == other.__isset.timeZone) && ((!__isset.timeZone) || (global::System.Object.Equals(TimeZone, other.TimeZone))))
        && ((__isset.inactive == other.__isset.inactive) && ((!__isset.inactive) || (global::System.Object.Equals(Inactive, other.Inactive))))
        && ((__isset.emphasized == other.__isset.emphasized) && ((!__isset.emphasized) || (global::System.Object.Equals(Emphasized, other.Emphasized))))
        && ((__isset.includeAllReadableNotebooks == other.__isset.includeAllReadableNotebooks) && ((!__isset.includeAllReadableNotebooks) || (global::System.Object.Equals(IncludeAllReadableNotebooks, other.IncludeAllReadableNotebooks))))
        && ((__isset.includeAllReadableWorkspaces == other.__isset.includeAllReadableWorkspaces) && ((!__isset.includeAllReadableWorkspaces) || (global::System.Object.Equals(IncludeAllReadableWorkspaces, other.IncludeAllReadableWorkspaces))))
        && ((__isset.context == other.__isset.context) && ((!__isset.context) || (global::System.Object.Equals(Context, other.Context))))
        && ((__isset.rawWords == other.__isset.rawWords) && ((!__isset.rawWords) || (global::System.Object.Equals(RawWords, other.RawWords))))
        && ((__isset.searchContextBytes == other.__isset.searchContextBytes) && ((!__isset.searchContextBytes) || (TCollections.Equals(SearchContextBytes, other.SearchContextBytes))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.order)
        {
          hashcode = (hashcode * 397) + Order.GetHashCode();
        }
        if(__isset.@ascending)
        {
          hashcode = (hashcode * 397) + Ascending.GetHashCode();
        }
        if((Words != null) && __isset.words)
        {
          hashcode = (hashcode * 397) + Words.GetHashCode();
        }
        if((NotebookGuid != null) && __isset.notebookGuid)
        {
          hashcode = (hashcode * 397) + NotebookGuid.GetHashCode();
        }
        if((TagGuids != null) && __isset.tagGuids)
        {
          hashcode = (hashcode * 397) + TCollections.GetHashCode(TagGuids);
        }
        if((TimeZone != null) && __isset.timeZone)
        {
          hashcode = (hashcode * 397) + TimeZone.GetHashCode();
        }
        if(__isset.inactive)
        {
          hashcode = (hashcode * 397) + Inactive.GetHashCode();
        }
        if((Emphasized != null) && __isset.emphasized)
        {
          hashcode = (hashcode * 397) + Emphasized.GetHashCode();
        }
        if(__isset.includeAllReadableNotebooks)
        {
          hashcode = (hashcode * 397) + IncludeAllReadableNotebooks.GetHashCode();
        }
        if(__isset.includeAllReadableWorkspaces)
        {
          hashcode = (hashcode * 397) + IncludeAllReadableWorkspaces.GetHashCode();
        }
        if((Context != null) && __isset.context)
        {
          hashcode = (hashcode * 397) + Context.GetHashCode();
        }
        if((RawWords != null) && __isset.rawWords)
        {
          hashcode = (hashcode * 397) + RawWords.GetHashCode();
        }
        if((SearchContextBytes != null) && __isset.searchContextBytes)
        {
          hashcode = (hashcode * 397) + SearchContextBytes.GetHashCode();
        }
      }
      return hashcode;
    }

    public override string ToString()
    {
      var tmp70 = new StringBuilder("NoteFilter(");
      int tmp71 = 0;
      if(__isset.order)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("Order: ");
        Order.ToString(tmp70);
      }
      if(__isset.@ascending)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("Ascending: ");
        Ascending.ToString(tmp70);
      }
      if((Words != null) && __isset.words)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("Words: ");
        Words.ToString(tmp70);
      }
      if((NotebookGuid != null) && __isset.notebookGuid)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("NotebookGuid: ");
        NotebookGuid.ToString(tmp70);
      }
      if((TagGuids != null) && __isset.tagGuids)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("TagGuids: ");
        TagGuids.ToString(tmp70);
      }
      if((TimeZone != null) && __isset.timeZone)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("TimeZone: ");
        TimeZone.ToString(tmp70);
      }
      if(__isset.inactive)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("Inactive: ");
        Inactive.ToString(tmp70);
      }
      if((Emphasized != null) && __isset.emphasized)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("Emphasized: ");
        Emphasized.ToString(tmp70);
      }
      if(__isset.includeAllReadableNotebooks)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("IncludeAllReadableNotebooks: ");
        IncludeAllReadableNotebooks.ToString(tmp70);
      }
      if(__isset.includeAllReadableWorkspaces)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("IncludeAllReadableWorkspaces: ");
        IncludeAllReadableWorkspaces.ToString(tmp70);
      }
      if((Context != null) && __isset.context)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("Context: ");
        Context.ToString(tmp70);
      }
      if((RawWords != null) && __isset.rawWords)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("RawWords: ");
        RawWords.ToString(tmp70);
      }
      if((SearchContextBytes != null) && __isset.searchContextBytes)
      {
        if(0 < tmp71++) { tmp70.Append(", "); }
        tmp70.Append("SearchContextBytes: ");
        SearchContextBytes.ToString(tmp70);
      }
      tmp70.Append(')');
      return tmp70.ToString();
    }
  }

}
